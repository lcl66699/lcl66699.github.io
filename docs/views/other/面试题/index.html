<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script src="">
        const curry = (fn, ...args) => {
            // 函数的参数个数可以直接通过函数数的.length属性来访问
            return args.length >= fn.length // 这个判断很关键！！！
                // 传入的参数大于等于原始函数fn的参数个数，则直接执行该函数
                ? fn(...args)
                /**
                 * 传入的参数小于原始函数fn的参数个数时
                 * 则继续对当前函数进行柯里化，返回一个接受所有参数（当前参数和剩余参数） 的函数
                */
                : (..._args) => curry(fn, ...args, ..._args);
        }

    </script>
    <script src="">

        const add = (...args) => {
            return args.reduce((a, b) => a + b)
        }

        const curry = (fn) => {
            let args = []
            return function curring(..._args) {
                if (_args.length) {//还有参数
                    args.push(..._args)
                    // args = [...args, ..._args]
                    return curring
                } else {
                    let res = fn.apply(this, args)
                    args = []//如果不清空再次调用的时候，会有残留
                    return res
                }
            }
        }

        const curryAdd = curry(add)

        console.log(curryAdd(1, 2, 3)());//注意调用的时候，需要()再调用
        console.log(curryAdd(1)(2)(3)());
        console.log(curryAdd(1, 2)(3)());
        console.log(curryAdd(1)(2, 3)());

    </script>
    <script>
        // 实现async await
        // async await是语法糖，本质还是生成器
        const sleep = (str) => {

            return new Promise((resolve, reject) => {
                setTimeout(() => resolve(str), 1000)
            })
        }

        function* test() {
            console.log('开始了');
            const res1 = yield sleep('hello 1')
            console.log('第二部', res1);
            const res2 = yield sleep('hello 2')
            console.log('第三步', res2);

        }
        //启动生成器
        const gen = test()

        const one = gen.next('这是第一次执行的参数')
        one.value.then((res) => {
            console.log(res);
        })

        console.log(one);
        const er = gen.next('这是第2次执行的参数')
        er.value.then((res) => {
            console.log(res);
        })
        console.log(er);
        const san = gen.next('这是第3次执行的参数')

        console.log(san);
    </script>
</body>

</html>