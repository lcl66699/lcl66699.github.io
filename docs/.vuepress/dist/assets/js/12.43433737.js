(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{378:function(t,a,s){"use strict";s.r(a);var n=s(42),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"react"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),s("p",[t._v("安个vs的小插件   安好输入rcc  可快捷创建类 rfc快速创建函数")]),t._v(" "),s("h2",{attrs:{id:"react介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react介绍"}},[t._v("#")]),t._v(" React介绍")]),t._v(" "),s("p",[t._v("Facebook,React主要是用于构建用户界面的JavaScript 库，实现单页面应用。")]),t._v(" "),s("ul",[s("li",[t._v("单页面应用和多页面应用\n"),s("ul",[s("li",[t._v("多页面应用:页面跳转时跳转的都是完整的html页面")]),t._v(" "),s("li",[t._v("单页面应用:只有1个html页面，所有内容都在这个页面中展示，通过“路由”来加载不同内容。全部是通过js来控制显示的。")])])]),t._v(" "),s("li",[t._v("单页面应用的优缺点:\n"),s("ul",[s("li",[t._v("优点:用户体验比较好，加载比较流畅")]),t._v(" "),s("li",[t._v("缺点:不利于seo(网站优化，能影响搜索排名)")])])]),t._v(" "),s("li",[t._v("特点:声明式设计(采用声明范式)、高效、灵活、JSX语法、组件、单向响应的数据流\n创建项目,脚手架：下载别人写好的配置\n"),s("code",[t._v("npm i -g yarn")]),t._v("先安这个 再安下面的更快")])]),t._v(" "),s("p",[s("code",[t._v("npx create-react-app my-app")])]),t._v(" "),s("p",[t._v("安装时还可以先把脚手架下载好，再通过脚手架下载项目")]),t._v(" "),s("p",[s("code",[t._v("npm i -g create - react -app")]),t._v(" "),s("code",[t._v("create -react- app my- appcreate -react- app my- app")])]),t._v(" "),s("p",[t._v("npx: npm中的个功能，\n    npx的执行分3步，第一步:下载脚手架，第二步: 使用脚手架安装项目。第三步:下载好项目后删除脚手架。")]),t._v(" "),s("h2",{attrs:{id:"目录结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目录结构"}},[t._v("#")]),t._v(" 目录结构")]),t._v(" "),s("ul",[s("li",[t._v("项目依赖的包")]),t._v(" "),s("li",[t._v("pubic：静态文件")]),t._v(" "),s("li",[t._v("src ：前台文件代码的文件夹\n"),s("ul",[s("li",[t._v("index.js 入口")]),t._v(" "),s("li",[t._v("app.js 入口文件渲染的页面")]),t._v(" "),s("li",[t._v("App.test.js测试文件 不用管")]),t._v(" "),s("li",[t._v("serviceWorker.js PWA配置文件 不用管")])])]),t._v(" "),s("li",[t._v(".gitignore git上传时的忽略配置")]),t._v(" "),s("li",[t._v('package.json\n        "scripts": {\n            "start": "react-scripts start",//启动开发阶段服务器\n            "build": "react-scripts build",//打包\n            "test": "react-scripts test",//运行测试\n            "eject": "react-scripts eject"//显示隐藏的配置\n        },')]),t._v(" "),s("li",[t._v("运行npm run eject 时， 提示: Are you sure you want to eject? This action is permanent .(这个)\n"),s("code",[t._v("npm run eject")]),t._v("\n运行eject后会多出config文件夹和scripts文件夹\n"),s("ul",[s("li",[t._v("config:里面是webpack的配置")]),t._v(" "),s("li",[t._v("scripts:是启动命令的配置")])])])]),t._v(" "),s("h2",{attrs:{id:"jsx语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsx语法"}},[t._v("#")]),t._v(" jsx语法")]),t._v(" "),s("ol",[s("li",[t._v("在js中可以直接写html\n"),s("ul",[s("li",[t._v("HTML部分:直接写html标签")]),t._v(" "),s("li",[t._v("JS部分:写在{}内")]),t._v(" "),s("li",[t._v("babel会把j sx转成React. createElement( )")]),t._v(" "),s("li",[t._v("React. createElement()方法是创建react元素(虚拟DOM)的方法")]),t._v(" "),s("li",[t._v("ReactDOM. render()的第一 个参数，需要的就是react元素")])])]),t._v(" "),s("li",[t._v("jsx的特点\n"),s("ul",[s("li",[s("p",[t._v("大括号中写的js表达式,注意，大括号中不能直接渲染对象，能渲染数组(不能有普通对象)")])]),t._v(" "),s("li",[s("p",[t._v("JSX属性：写在标签的属性上")]),t._v(" "),s("ul",[s("li",[t._v("改名"),s("code",[t._v("<div className=''></div>")]),t._v(" "),s("code",[t._v("<label htmlfor=''></label>")])]),t._v(" "),s("li",[t._v("标签上添加行内样式时，需要使用对象形式")]),t._v(" "),s("li",[s("code",[t._v("<div id={uid}  style={color:'red',fontSize:'14px'}></div>")])])])]),t._v(" "),s("li",[s("p",[t._v("react元素是不可变的,如果需要更新页面显示，就需要创建新的react元素")])])])]),t._v(" "),s("li",[t._v("元素渲染\nReactDOM.render(react元素)\nreact元素写法:\n"),s("ul",[s("li",[t._v("直接使用jsx语法: "),s("code",[t._v("<div>{uname}</div>")])]),t._v(" "),s("li",[t._v("使用 "),s("code",[t._v("React. createElement()")])])])]),t._v(" "),s("li",[t._v("使用组件"),s("code",[t._v("<App />")]),t._v(" "),s("code",[t._v("ReactDOM.render(<Home/>,document.getElementById('root'))")])])]),t._v(" "),s("h2",{attrs:{id:"组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[t._v("#")]),t._v(" 组件")]),t._v(" "),s("ol",[s("li",[t._v('概念:从概念上类似于JavaScript 函数。它接受任意的入参(即"props") ，并返回用于描述页面展示内容的React元素。组件允许你将UI拆分为独立可复用的代码片段，并对每个片段进行独立构思。')]),t._v(" "),s("li",[t._v("创建方式\n"),s("ul",[s("li",[t._v("函数式组件")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("App")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("props"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),t._v("函数组件不用hook语法时，功能弱j，有hook语法后 替代类形式组件。\n"),s("ul",[s("li",[t._v("类形式组件")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("App")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentWillMount")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    states"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])]),t._v(" "),s("p",[t._v("前期使用类组件，会学习类组件中的state,生命周期函数。不管什么组件 必须引入react7")]),t._v(" "),s("h3",{attrs:{id:"类形式组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类形式组件"}},[t._v("#")]),t._v(" 类形式组件")]),t._v(" "),s("h4",{attrs:{id:"创建组件rcc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建组件rcc"}},[t._v("#")]),t._v(" 创建组件rcc")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Home")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v(" \n说明：\n   1. 组件名称首字母要求大写\n   2. 需要继承React.Component这个类\n   3. 必须有一个render函数，render必须return，return后写的是jsx语法\n#### 导出组件\n    ")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("Home"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\n    ")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" Home"),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\n#### 导入组件\n    ")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("Home"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'path'")]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\n    ")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" AppHome "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'path'")]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\n#### 使用组件,当成标签使用\n    ")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Home "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\n    ")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Home"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Home"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\n### 组件复用\n把页面中的某一块UI拆分出去，做成一个组件，在原来的位置调用组件即可。\n## props\n- 当React元素为用户自定义组件时，它会将JSX 所接收的属性(attributes) 转换为单个对象传递给组件，这个对象被称之为“props”。\n- 调用组件时可以通过属性的形式定义传递数据\n")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Item data"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'string'")]),t._v(" arr"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\n")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Item picurl"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("picurl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" title"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("title"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\n在Item组件可以通过props对象，获取到用户调用组件时传入的数据\n\n")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),t._v("js\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Item")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Component")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// {data:'string ' ,arr:[1,2,3,4]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("ul",[s("li",[t._v("传递数据时，多个组件调用定义的属性名要一致。")]),t._v(" "),s("li",[t._v("可以使用 ... 扩展运算符")]),t._v(" "),s("li",[t._v("还可以遍历时传递数据")]),t._v(" "),s("li",[t._v("props是只读属性")])]),t._v(" "),s("h2",{attrs:{id:"jsx中的循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsx中的循环"}},[t._v("#")]),t._v(" JSX中的循环")]),t._v(" "),s("p",[t._v("不能使用for循环,使用map()方法遍历对象或数组\n"),s("code",[t._v("arr/obj.map(function(item,index){ return item })")])]),t._v(" "),s("h2",{attrs:{id:"state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[t._v("#")]),t._v(" state")]),t._v(" "),s("ul",[s("li",[t._v("state是定义组件内部自己使用的数据")]),t._v(" "),s("li",[t._v("在类组件中有两种定义方式\n"),s("ul",[s("li",[t._v("第一种：在constructor方法中定义")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    count"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("ul",[s("li",[t._v("第二种：直接在组件中定义")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("            state "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                count"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),s("li",[t._v("使用state数据\n"),s("code",[t._v("this.state.xx")])]),t._v(" "),s("li",[t._v("修改state数据,必须！this.setState()方法\n"),s("ul",[s("li",[t._v("用法1：对象形式的"),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    count"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" state "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" count "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])]),t._v(" "),s("li",[t._v("用法2：函数形式的"),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        count"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])])])]),t._v(" "),s("li",[t._v("this.setState()方法有批量更新功能")])]),t._v(" "),s("p",[s("code",[t._v("this.setState({count:this.state.count+1})")])]),t._v(" "),s("ul",[s("li",[t._v("this.setState()方法 可能是异步的")])]),t._v(" "),s("p",[s("code",[t._v("this.setState({},()=>{})")])]),t._v(" "),s("p",[t._v("什么时候是异步的：不放在其他宏任务或微任务中 当setState直接放在事件的宏任务中执行时，是异步的")]),t._v(" "),s("p",[t._v("什么时候是同步的：setState又被放在别的宏任务中,或者其他的微任务中")]),t._v(" "),s("p",[t._v("- setState的函数形式：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        count"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("函数中有一个参数state,这个state是谁?")]),t._v(" "),s("p",[t._v("state是上一次操作完state的结果(永远是最新的数据)\n加this不累加,算最后一个;不加this的话,就累加加的多")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("button onClick"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("state")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        page"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("page"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("state")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        page"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("page"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("state")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        page"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("page"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("button"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("h2",{attrs:{id:"生命周期函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期函数"}},[t._v("#")]),t._v(" 生命周期函数")]),t._v(" "),s("p",[t._v("又叫钩子函数，在组件运行的过程会在某些指定的条件下自动触发执行。\n组件有三个生命周期函数一生只触发一次：")]),t._v(" "),s("ul",[s("li",[t._v("componentWillMount")]),t._v(" "),s("li",[t._v("componentDidMount")]),t._v(" "),s("li",[t._v("componentWillUnMount")])]),t._v(" "),s("h3",{attrs:{id:"生命周期函数作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期函数作用"}},[t._v("#")]),t._v(" 生命周期函数作用")]),t._v(" "),s("ul",[s("li",[t._v("componentWillMount 组件渲染前，可能会放网络请求(不太建议)")]),t._v(" "),s("li",[t._v("componentDidMount 组件渲染完成，网络请求，全局事件绑定")]),t._v(" "),s("li",[t._v("shouldComponentUpdate(){return false;} 是否允许组件更新，优化使用")]),t._v(" "),s("li",[t._v("componentWillUpdate(){} 更新前，一般不做任何处理\n- componentDidUpdate(){} 组件更新完成，新网络请求\n- componentWillReceiveProps(){}props改变了 接收新的props，一般不做任何处理")]),t._v(" "),s("li",[t._v("componentWillUnmount(){} 组件销毁前，把全局绑定的事件、网络请求等有副作用的全部清除")])]),t._v(" "),s("h3",{attrs:{id:"事件系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件系统"}},[t._v("#")]),t._v(" 事件系统")]),t._v(" "),s("ul",[s("li",[t._v("react中自己重新定义事件系统，react绑定事件不需要获取到DOM元素，而是把事件绑定定义在虛拟DOM上了")]),t._v(" "),s("li",[t._v("语法:\n"),s("code",[t._v("<div on+事件名={EventFunction}></div>")]),t._v("\n说明：")])]),t._v(" "),s("ol",[s("li",[t._v("js的事件，驼峰命名法")]),t._v(" "),s("li",[t._v("EventFunction:对应的事件功能，编写的形式\n"),s("ol",[s("li",[t._v("直接定义一个箭头函数")]),t._v(" "),s("li",[t._v("可以定义函数\n如果是类形式组件，需要使用this.clickme, clickme函数定义在类中")])]),t._v(" "),s("div",{staticClass:"language-jsx extra-class"},[s("pre",{pre:!0,attrs:{class:"language-jsx"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("App")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("clickme")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("onClick")]),s("span",{pre:!0,attrs:{class:"token script language-javascript"}},[s("span",{pre:!0,attrs:{class:"token script-punctuation punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("clickme"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n    }\n}\n")])])])])])]),t._v(" "),s("h3",{attrs:{id:"this指向问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this指向问题"}},[t._v("#")]),t._v(" this指向问题")]),t._v(" "),s("p",[t._v("在react中，自定义事件中this默认是指向undefined的。")]),t._v(" "),s("ul",[s("li",[t._v("在react组件的生命周期函数中，this指向当前组件")]),t._v(" "),s("li",[t._v("在react class定义的组件中，constructor构造方法中需要通过调用super()方法生成this，这时\tthis指向当前组件；否则不存在this，使用会报错。")]),t._v(" "),s("li",[t._v("在react 组件中，自定义function函数中this默认指向undefined）")])]),t._v(" "),s("p",[t._v("如果想让this指向当前组件    I")]),t._v(" "),s("ul",[s("li",[t._v("方法1:使用bind,改变this指向")]),t._v(" "),s("li",[t._v("方法2：使用箭头函数")]),t._v(" "),s("li",[t._v("方法3：在constructor构造方法中通过bind绑定this")])]),t._v(" "),s("div",{staticClass:"language-jsx extra-class"},[s("pre",{pre:!0,attrs:{class:"language-jsx"}},[s("code",[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("onClick")]),s("span",{pre:!0,attrs:{class:"token script language-javascript"}},[s("span",{pre:!0,attrs:{class:"token script-punctuation punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("clickme "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("clickme "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("clickme")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("如果当函数调用时没有传参，建议使用方法3(constructor中绑定)\n如果函数调用时需要传参，使用直接bind绑定更多一些")]),t._v(" "),s("h3",{attrs:{id:"事件对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件对象"}},[t._v("#")]),t._v(" 事件对象")]),t._v(" "),s("ul",[s("li",[t._v("事件对象不需要传递，直接调用就行，把事件对象方法函数形参的最后y一个位置")]),t._v(" "),s("li",[t._v("获取坐标信息\n"),s("code",[t._v("event.pagex / event . pageY")]),t._v("获取事件触发者  \n"),s("code",[t._v("e.preventDefault()")]),t._v("阻止冒泡\n"),s("code",[t._v("e.stopPropagation()")]),t._v(" 阻止默认事件")])]),t._v(" "),s("h3",{attrs:{id:"表单"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#表单"}},[t._v("#")]),t._v(" 表单")]),t._v(" "),s("ul",[s("li",[t._v("form标签\n"),s("code",[t._v("<form action= 'http://xx/xx.php/xx. jsp/xx.asp' method= 'get post' ></ form>")])]),t._v(" "),s("li",[t._v("ajax:不刷新页面，能实现页面的局部更新，有ajax后form用的很少了")]),t._v(" "),s("li",[t._v("表单:收集用户输入的信息\n"),s("ul",[s("li",[s("p",[t._v("第一种收集信息的形式：受控组件")]),t._v(" "),s("p",[t._v("受控组件：表单数据的显示和更改有react控制，具体是由react的state的控制。使 React 的 state 成为“唯一数据源”。\n"),s("code",[t._v("<input value={this.state.user} onChange={(e)=>this.setState({user:e.currentTarget.vale})} />")]),t._v("\n特殊的受控组件：单选按钮,多选按钮")]),t._v(" "),s("ul",[s("li",[t._v("value属性值不能改变")]),t._v(" "),s("li",[t._v("onChange事件只有在选中时触发")])])]),t._v(" "),s("li",[s("p",[t._v("第二种收集信息的形式：非受控组件\n允许用户获取到原生DOM，自己来操作数据")]),t._v(" "),s("ul",[s("li",[t._v("使用非受控组件获取input中值\n"),s("ul",[s("li",[t._v("创建ref ： React.createRef()")]),t._v(" "),s("li",[t._v("把创建ref添加到标签上，使用ref属性 ref={this.mref}")]),t._v(" "),s("li",[t._v("获取DOM，this.myref.current")])])])])])])])]),t._v(" "),s("h2",{attrs:{id:"状态提升"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态提升"}},[t._v("#")]),t._v(" 状态提升")]),t._v(" "),s("ol",[s("li",[t._v("数据的传递方向：\n父级向子级传递，使用props\n子级向父级传递，状态提升")]),t._v(" "),s("li",[t._v("用法\n"),s("ol",[s("li",[t._v("让父级向子级传递一个函数 "),s("code",[t._v("<Son user= getSonDate={this.getSonDate.bind(this)}/>")])]),t._v(" "),s("li",[t._v("在子级组件中调用传递来的这个方法 "),s("code",[t._v("this.props.getSonDate(this.state.user)")])]),t._v(" "),s("li",[t._v("在子级组件中调用这个函数时可以传递实参 "),s("code",[t._v("this.setState({list:cs})")])]),t._v(" "),s("li",[t._v("在父级函数中接收数据")])])])]),t._v(" "),s("div",{staticClass:"language-md extra-class"},[s("pre",{pre:!0,attrs:{class:"language-md"}},[s("code",[s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("##")]),t._v(" 组合")]),t._v("\n    1. 有些组件无法提前知晓它们子组件的具体内容。在Sidebar (侧边栏)和Dialog (对话框)等展现通用容器(box)的组件中特别容易遇到这种情况。我们建议这些组件使用一个特殊的childrenprop來将他们的子组件传递到渲染结果中\n    2. 用法:\n        1. 定义一个组件，组件中使用特殊的children prop属性\n \t\t\t\t\t{this.props.children}\n        2. 使用这个组件，作为双标签使用，在双标签内部定义具体内容\n\t\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("TopBar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        \t\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("首页"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        \t\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("组件"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n      \t\t\t\t"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("TopBar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        3. 定义组件时使用childrenprop的位置就能显示双标签中的内容\n    3. React.createElement(type,options,children)\n        type :标签类型\n        options:属性集合\n        children:子级元素\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("id")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("odiv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("className")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("box"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("span")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("ddd"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("span")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        React.createElements('div',{id='odiv', className='box'},React.createElements('span',{},'ddd'))\n3. props类型验证\n    1. PropTypes类型检测:父级向子级传递数据时，是否是子级要求的数据类型，如果不是PropTypes会报警告。\n    2. 使用步骤\n        1. 引入验证包\n            import PropTypes from 'prop-types' ;\n        2. 定义需要验证的prop属性\n            类组件中用法：\n            组件名.propTypes={\n                count:propTypes.string //验证单个类型\n                msg：propTypes.oneOfType([//验证多种类型\n                    propTypes.number,\n                    propTypes.string\n                ]),\n                vnode:propTypes.element.isRequired//验证必须项\n            }\n            第二种写法：\n                static propTypes ={}\n    3. 给props定义默认值\n            类名.defaultProps={\n                msg:'hello',\n                obj:{}\n            }\n    4. 执行顺序\n        默认值比验证执行的早\n\n4. fetch网络请求\n    1. 介绍:\n        1. 是es6中提供的一种新的网络请求方式。Fetch API 提供了一个JavaScript接口，用于访问和操纵HTTP管道的部分，不是ajax 了。\n        2. fetch方法是一个全局方法，可以在任意位置使用\n        3. fetch()返回的Promise ，使用. then( )获取请求成功的结果,使用. catch捕获错误信息\n        4. 默认情况下，fetch不会从服务端发送或接收任何cookies, 要发送cookies,必须设置credentials 选项，credentials的默认值是 same-origin\n    2. 语法\n        fetch(url,{\n            method:''get/post',//默认get\n            body:data,//携带的是post数据\n            params:data//携带的是get数据\n            header:{//配置请求头\n                'Content-Type':'application/x-www-form-urlencoded' \n//post以form data形式传递数据\n            },\n            credentials:'same-origin', //是否允许携带cookie数据(include可携带)\n        })\n    3. 返回值：网络请求的结果 通过promise.then方法接收的\n        不可直接用，fetch提供了对应的解析方法\n        .blob() 把结果解析二进制\n        .text() 把结果解析字符串\n        .json() 把结果解析json对象\nthen(data=>data. json())\nthen( data=>{ console . log(data)})\n        解析后的json对象格式：key：value\n            {\n                data：{}//真实请求结果\n                status：200，\n                header：{}\n            }\n    4. 请求携带数据\n       1. get\n            1. 问号携带数据\n                携带形式：url?key=value&key=value\n            2. restful数据\n                携带形式：url/value/value2\n                要求后台识别哪些是路径，哪些是数据\n        2. post\n            1. 需要加请求头header，method\n            2. 传递的数据需要放在body上，而且是'key=value&key=value' 的字符串\n    5. 跨域解决\n        1. cors : 后台配置，前台不需要管\n        2. jsonp : 使用 fetch-jsonp插件\n            1. 下载安装 npm i fetch-jsonp\n            2. 引入插件\n            3. 使用插件请求\n    \t\t getJsonp(){\n       \t\t\t fetchJsonp('http://localhost:5000/kuayu')\n       \t\t\t .then(data=>data.json())\n       \t\t\t .then(data=>console.log(data))\n\t\t\t\t}\n\n        3. 代理\n            1. 在package.json中写\n\"proxy\": \"http://localhost:5000\"\n\n                1. package.json中有一个字段：proxy,这个字段可以实现一个代理\n                2. 重启前台服务\n                3. 前台调用接口时只需要写接口名称，不写代理地址\n            2. 使用http-proxy-middleware中间件\n                1. 下载安装： npm i http-proxy-middleware\n                2. 在src目录下创建一个setupProxy.js文件\n                3. 编写配置\nlet {createProxyMiddleware} = require('http-proxy-middleware');\nmodule.exports =function(app){\napp.use(createProxyMiddleware('/inex',{\ntarget:'https://3g.163.com//touch/reconstruct/article/list',\nchangeOrigin:true,\npathRewrite:{\n'/inex':''\n}\n}))\n}\n\n4. 网络请求时：/inex/接口名称\n\nDAY 4\n"),s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" router 路由")]),t._v("\n1. 路由介绍:react主要实现单页面应用，也有切换内容显示的需求，定义一个可以根据不同的路径加载不同的内容的功能，这个功能就叫路由\n    路由常用的有两种实现方法:\n        1. hash路由，根据路径中的hash值来决定显示页面\n        2. history路由：使用h5中的history对象\n2. 安装:\n    npm i -S react-router-dom\n3. 配置\n    1. 先决定使用哪种路由模式(hash,history)\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("HashRouter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("HashRouter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("  #\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("BrowserRouter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("BrowserRouter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" //\n        提供了一个路由容器,在容器中定义具体\n        路由，那么定义的路由就会按照决定好的路由模式来显示。\n    2. 定义具体的路由\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Route")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/about"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("compoent")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{about}/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        path:是路径，会在浏览器地址栏显示\n        component：要加载的页面\n        exact：精准匹配\n    3. Route的特点:贪婪匹配\n        不想贪婪，想一次加载一个路由，实现方式2种:\n        1. exact精准匹配\n        2. react-router-rom还提供了一个标签,"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Switch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(",作用是显示匹配到的第一个Path\n    4. Link标签，导航\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("exact")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("去哪"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("link")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    5. 动态路由\n        1. 定义路由时，规定哪些部分是动态的，如果是动态需要使用:variable 形式定义\n           "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Route")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/detail/:newsid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("component")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{Detail}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        2. 跳转时(Link),需要给动态参加具体的数据\n             "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/detail/1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),t._v("  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("去哪"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("link")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n<Link to={ /detail/${id}^ }>详情"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("L")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("ink")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n<Link to={{ \npathpame: /detail/${id} |\n}}>\n遍历\n{this.state.arr.map((ele,index)=>("),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("key")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{index}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{`/detail/${ele.id}`}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("{ele.user}"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Link")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("))}\n        3. 在跳转后的组件中可以获取到动态路由的具体参数值\n            从props.match.params这个对象获取\n\n    6. Route加载的组件的props.上会自动多3个对象(history,match,loaction)\n        history:h5的history对象，里面有push, goBack等常用浏览器的操作方法\n        locatin:经过封装的浏览器的loaction对象\n        match：接受路由参数的\n    7. 路由嵌套\n        1. 路由到的页面中又有其他的路由\n        2. 常见的二层嵌套，多层嵌套\n            1. 两层嵌套\n                外层把组件作为路由标签用，在组件的属性上使用path属性，来定义路径内层被嵌套的组件使用"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Route")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("来定义\n                在外层组件内部需要使用props. children来显示子级路由\n                注意:内层路由路径要把父级的路径带上\n  APP.js："),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Kemu")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/kemu"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n              "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Route")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/kemu/keyi"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("component")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{Keyi}/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n              "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Route")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/kemu/Keer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("component")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{Keer}/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n              "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Route")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/kemu/Kesan"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("component")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{Kesan}/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n              "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Route")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/kemu/Kesi"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("component")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{Kesi}/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Kemu")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\nKemu.js\n "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("h1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("驾照考试"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("h1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/kemu/keyi"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("科111"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Link")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n          \t\t"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/kemu/Keer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("科222"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Link")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n          \t\t"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/kemu/Kesan"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("科333"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Link")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n          \t\t"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/kemu/Kesi"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("科444"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Link")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n                    {this.props.children}\n                "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\n            2. 多层嵌套\n                1. 不能把组件作为标签使用了\n                2. 定义在组件内部，在组件内部使用"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Route")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("来定义路由\n                    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Link")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("定义导航\nfunction Keer(props) {\n  return ("),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("科二\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Route")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/kemu/Keer/Daoche"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("component")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{Daoche}/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Link")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/kemu/Keer/Daoche"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("倒车"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Link")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(")\n}\n\n    8. 路由重定向\n        1. 引入标签"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Redirect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n        2. 用法\n            1. <Route path=' /a' render={()=>{"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Redirect")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("}}>\n            2. 直接作为标签使用\n                "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Redirect")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("from")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n            3. 在Route双标签内使用\n                "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Route")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Redirect")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("to")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Route")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    9. 路由高亮\n        1. 引入NavLink标签\n        2. 这个标签在被选中时，能自动添加类名\n        3. 自己添加css样式\n    10. 编程式导航\n        - 就是使用history的导航功能实现的\n        - history.push() //正常的导航，会把这层路径添加到浏览器的历史记录中\n        - history.replace() //替换导航\n        - history.goBack() //返回上一层路径\n        - history.go(number) //前进或后退\n    11. withRouter()\n        - 有些页面访问不到，如果想在这种页面使用编程式导航\n        - withRouter是react-router 提供的一个高阶组件，使用这个函数调用时把不能访问\n        history对象的组件放在实爹位置上，就可以返回一个新组件，这个新组件就具备了history ,loaction，match对象\nimport {withRouter} from 'react-router'//引入\nlet Newkemu=withRouter(kemu)//引用\nexport default Newkemu //导出\n\n        - 除了withRouter,还可以通过props传参形式由父级传递下来\n\n"),s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" antd")]),t._v("\n- antd 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品\n- 使用\n    1. 安装：npm install antd --save\n    2. 引入\n        1. 全部引入css\n            优点：不需要考虑css问题，引入任何组件都有css\n            缺点：有很多css用不到\n            import 'antd/dist/antd.css'\n        2. 按需引入\n             用哪个组件，就动态的添加这个组件需要的css\n                第一种方式：craco库\n                第二种方式：\n\nDay5\n"),s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" 配置less")]),t._v("\n- 使用create-react-app脚手架创建的项目，默认是不支持less。如果想在项目中使用less就需要自己配置\n- 常用的方法：\n    0. 首先下载 less 和 less-loader \n    1. 直接修改webpack的配置\n        1. 运行 npm run eject ： 把webpack的配置文件显示出来\n        2. 在webpack.config.js中进行修改\n            1. 先搜索rules，直接自己添加loader配置\n                {\n                    test:/\\.less/,\n                    use:['style-loader','css-loader','less-loader']\n                }\n            2. 参照sass的配置，搜索sass\n                复制sass的配置，把其中的sass修改为less\n    2. 使用中间件\n        1. craco库，@craco/less插件\n        2. customize-cra react-app-rewired库\n\n2. mock\n    1. 作用：生成随机数据，拦截 Ajax 请求\n    2. 优点：\n        前后端分离   开发无侵入\n    3. 安装及使用\n        npm install mockjs\n    4. 数据模板定义规范：\n        数据模板中的每个属性由 3 部分构成：属性名(name)、生成规则(rule)、属性值(value)\n        语法：'name|rule': value\n        生成规则 有 7 种格式：\n        'name|min-max': value\n        'name|count': value\n        'name|min-max.dmin-dmax': value\n        'name|min-max.dcount': value\n        'name|count.dmin-dmax': value\n        'name|count.dcount': value\n        'name|+step': value\n    5. 数据占位符定义规范：\n        占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中\n        语法：@占位符 cname\n        @占位符(参数 [, 参数])\n        注意：\n        1.用 @ 来标识其后的字符串是 占位符。\n        2.占位符 引用的是 Mock.Random 中的方法\n        3.通过 Mock.Random.extend() 来扩展自定义占位符。\n        4.占位符 也可以引用 数据模板 中的属性。\n        5.占位符 会优先引用 数据模板 中的属性。\n        6.占位符 支持 相对路径 和 绝对路径\n    6. 拦截网络请求\n        Mock.mock(url,type,template)\n3. 小项目\n\n\n\nDay6\n1. \n2.\n 作用：可以不通过props一层一层的传递数据，通过Provider提供数据，在组件树之间可以直接获取数据。\n    1. 数据传递方向有父传子 (props),子传父 (事件)\n        这两种形式都需要一层一层的传递\n    2. 作用：Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法\n    3. 使用\n        1. 创建Context.js\n            import React from 'react'\n              const Mycontext=React.createContext()\nexport default Mycontext\n\n        2. Mycontext.Provider : 提供数据\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Mycontext.Provider")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Comp")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Mycontext.Provider")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        3. Mycontext.Consumer : 获取数据\n             render() {\n        return (\n           "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Mycontext.Consumer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n               {(value)=>{\n                   console.log(value);\n                   return "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n                       item\n                       {value.sun}\n                       {value.pp}\n                   "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n               }}\n           "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Mycontext.Consumer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        )\n}\n\n        4. Class.contextType:获取数据\n            Class.contextType = Mycontext;//写在最下\n            在组件内可以使用context属性获取的数据 \n        5. static contextType：获取数据\n            static contextType = Mycontext;//在render的上一行\n            在组件内可以使用context属性获取的数据\n        6. contextType,Consumer 区别\n            contextType 调用多次时，只有最后一次生效\n            Consumer 调用多次，数据不覆盖\n\n\n\n2. 错误边界\n    1. react中一个页面中可能有很多组件，只要其中有一个组件运行出错，react会把页面中所有组件全卸载掉，显示空白屏幕\n    2. 错误边界:当React运行中有错误时，这时显示一个备用的页面，不显示白屏，还可以把报错信息发送到指定的位置\n    3. 用法：\n         错误边界也是一个组件，定义好后包裹其他的组件，这个组件必须是class定义的，同时这个组件中必须有以下两个生命周期函数中的至少一个\n             static getDerivedStateFromError(){\n       \t\t return {iserror:true}\n   \t\t\t\t }\n        渲染备用 UI\n            componentDidCatch(...rest){\n        console.log(rest);\n}\n        打印错误信息，可以把错误信息发送到指定位置\nrender() {\n        if(this.state.iserror){\n            return "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("组件报错了"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        }\n        return (\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n                {this.props.children}           \n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        )  \n}\n\nDay7\n"),s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" Refs 转发")]),t._v("\n1. ref是什么？允许用户获取到原生DOM\n2. ref放在组件上，这时current的值是谁？\n    就是这个组件\n3. ref放在组件上时，我想获取的是这个组件内部的某个DOM元素\n- react中组件上使用ref属性时，react会把ref从props中删除，根本不会传递到组件内部。\n- refs转发就是解决上面这个问题的\n4. 用法：\n    1. 创建ref 在父类\n      constructor(){\n        super()\n        this.ref1=React.createRef()\n}\n    在父类可以通过事件输出\n     console.log(this.ref1.current);\n    然后在组件中传过去ref "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Sonref")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("ref")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{this.ref1}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("msg")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("2006"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v(" \n    2. 使用forwardRef来创建组件\n       let Son=React.forwardRef((props,ref)=>{\n        return "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n           "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("ref")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{ref}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("son中的div"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n})\nexport default Son\n"),s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" Fragments")]),t._v("\n1. Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。\n2. 语法：\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("React.Fragment")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("React.Fragment")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n简写语法： <>...</>\n\n"),s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" 高阶组件")]),t._v("\n- 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式， 高阶组件本身是一个函数，接收一个组件，返回一个新组件\n  高阶组件是参数为组件，返回值为新组件的函数\n  代码如下\n\n//     // React的api, React.createElement(标签,{属性},children)\n//     // React的api, React.cloneElement(react元素,{属性},children)\n//     // React的api, React.Children.map()\n\n"),s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" 性能优化")]),t._v("\n- shouldComponentUpdate(nextProps,nextState)\nthis.props代表老状态，nextProps代表新状态\n是否允许组件更新\n- PureComponent （export default class Son2 extends PureComponent）\nPureComponent来定义类形式组件，只有当props或state发生改变时才会触发组件更新\n\n- ComponentWillUnmount 组件注销\n  // 组件销毁前，把全局的事件删除了 比如\n        window.removeEventListener('scroll',this.myscroll);\n        clearTimeout(this.state.timer);\n- ComponentDidUpdate(prevProps,prevState)\n 防止死循环 可以加条件判断\n\n"),s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" Render Props")]),t._v("\n- 术语 “render prop” 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，一些组件向外提供数据，不把需要数据的组件硬编程到这个组件内部，通过调用props.上\n的一个方法，把数据提供处理\n"),s("span",{pre:!0,attrs:{class:"token list punctuation"}},[t._v("-")]),t._v(" 语法\nData.jsx提供数据的组件\nclass Data extends Component {\nstate ={count:1}\nrender(){\nreturn "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("{this . props. render (this. state)}"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n}\n}\n在公共app.js，等于把state传给son\n <Data render={(state)=>{\n        console.log('ap',state);\n          return "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Son1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("state")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{state}/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n      }}/>  \nSon.jsx在通过this.props接数据\n\n"),s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" 懒加载")]),t._v("\n- 当组件什么时候使用到了，再动态加载这个组件\n- 使用：\nlet About = React.lazy(()=>import('./About'));\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Suspense")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("fallback")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{<Loading")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("}>\n                "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("About")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Suspense")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\nDay8\n"),s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" hooks hook作用：让函数式组件能使用state和生命周期")]),t._v("\n1. 介绍：Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 rfc快速创建\n    hook是给函数组件使用的，hook只能在函数组件中使用，不能在class组件中使用\n    没有破坏性改动，100%向后兼容，react版本大于16.8就可以直接使用Hook\n2. State Hook\n    1. 语法：\n        import React,{useState} from 'react'\n        const [count, setCount] = useState(0);\n    2. 调用\n        直接使用变量名 count\n    3. 修改\n        调用setCount方法\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!-- 第一种用法：在老状态上修改 --\x3e")]),t._v("\n            setCount((count)=>{\n                //count是老的状态\n                return count + 5//没有批量更新\n            })\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!-- 第二种用法：设置成固定值 --\x3e")]),t._v("\n            setCount(2)\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!-- 第三种用法： --\x3e")]),t._v("\n            setCount(count+2) //有批量更新功能\n    4. 是否是批量更新\n        setCount(count=>count+1):不批量更新，写几个就执行几次\n    5. 是否是异步\n        在非其他宏任务或微任务中时是异步的， 否则同步执行的\n\n2. Effect Hook\n    1. useEffect 是给函数组件提供 \"生命周期\" 的一个函数，相当于有3个生命周期\n    2. 语法：\n        1. 引入\n            import React,{useEffect} from 'react'\n        2. 使用：\n            useEffect(()=>{\n                ...\n                return ()=>{}\n            },[])\n            1. 第一个参数位置是函数，作用相当于componentDidMount和componentDidUpdate\n            2. 第二个参数位置是一个数组，可选的。这个数组是对componentDidUpdate优化使用的\n                1. 不写第二个参数时：第一个参数位置的函数，在组件更新时会重新执行\n                2. 第二个参数位置写空数组([])：禁止ComponentDidUpdate执行\n                3. 第二次参数位置数组中有值：只有数组中的参数的值发生改变时，才能执行ComponentDidUpdate\n            3. 第一个参数位置的函数中的返回值(return) : 相当于componentWillUnmount，effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次。这个设计可以帮助我们创建 bug 更少的组件。\n\n3. Context Hook\n- 在函数组件中使用Context的hook\n- 语法：\n        这是获取数据 const value = useContext(MyContext);\n        提供数据：Context.Provider\nuseContext\n    1. 在函数组件中获取Context提供的数据\n    2. 用法：\n        1. 创建Context,提供数据\n            Let Mycontext = React.createContext() //写在export前面\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Mycontext.Provider")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{{}}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Son")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Mycontext.Provider")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\nexport {Mycontext}\n        2. 在函数组件中调用useContext获取数据\n            function Son(){\n                let value = useContext(Mycontext);\n            }\n        3. 在函数组件中还可以使用Consumer获取数据\n            function Son (){\n                "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Mycontext.Consumer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n                {\n                   (value)=>{\n                        console.log(value);\n                        \n                    }\n                }"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Mycontext.Consumer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n            }\n\n4. Hook 规则\n    1. 只在最顶层使用 Hook,不要在循环，条件或嵌套函数中调用 Hook\n    2. 只在 React 函数中调用 Hook\nDay9\n"),s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" 新知识点")]),t._v("\n1.  useReducer 是功能更强大的\"useState\"\n    1. 语法:\n        const [state, dispatch] = useReducer(reducer, initialArg, init)\n        2. dispatch：是useReducer产生的一个操作方法\n            dispatch执行时需要传递一个对象 {type:'ADD',payload:'data'}\n        3. reducer：提供对数据进行操作的方案\n            function reducer(state,action){\n                switch(action.type){\n                    case 'ADD':\n                        state = state + 1;\n                        return state;\n                    default:\n                        return state;\n                }\n            }\n    3. 使用：\n        直接调用变量名\n    4. 修改：\n        调用dispatch方法\n\n"),s("span",{pre:!0,attrs:{class:"token title important"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("#")]),t._v(" 注意：<React.StrictMode>严格模式")]),t._v("\n- 检测意外的副作用\n    严格模式不能自动检测到你的副作用，但它可以帮助你发现它们，使它们更具确定性。通过故意重复调用以下函数来实现的该操作：\n    class 组件的 constructor，render 以及 shouldComponentUpdate 方法\n    class 组件的生命周期方法 getDerivedStateFromProps\n    函数组件体\n    状态更新函数 (即 setState 的第一个参数）\n    函数组件通过使用 useState，useMemo 或者 useReducer\n这仅适用于开发模式。生产模式下生命周期不会被调用两次。\n\n2. useMemo\n    1. 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算\n    2. const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n\n3. useRef\n    1. useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。\n    2. 用法：\n         1. 创建ref\n\t\t2. 语法：const myref = useRef()\n\t\t3. 使用\n        \t\t"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("ref")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{myref}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\t\t4. refs转发\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Son")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("ref")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{myref}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n        Son组件创建时，需要使用 React.forwardRef()创建\n            React.forwardRef((props,ref)=>{\n                return "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("ref")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{ref}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n            })\n\n\n4. 自定义hook\n    1. 提取组件中的业务逻辑\n    2. 语法：\n        必须以 'use' 开头，可以使用内置hook\n        function useXx(){\n            const [list,setList] = useState([]);\n            useEffect(()=>{\n            },[])\n            return list\n        }\n    3. 使用：\n        在组件中直接调用即可\n        注意：1. 只能在函数组件中使用\n              2. 不能放在 if,for,普通函数中调用\n\n\n\nDay10 redux\n1. 在react中数据传递方式有几种?\n    1. 父传子： props\n    2. 子传父： 使用事件\n    3. Context：提供公共数据\n\n2. Context的缺点：\n    1. 公共数据特别多\n    2. 组件也特别多时\n    当上面两种情况同时存在时，最好把Context定义在App.js组件上\n    但是都定义App.js上，会造成App.js组件上多很多对App组件来说没用的数据\n    所以会有需求：把公共数据提取出去，单独放在一个存储空间中，使用数据时就从这个空间中取，修改时就修改这个空间中的数据。\n3. redux\n    1. 作用：把公共数据提取出去，单独放在一个存储空间中，使用数据时就从这个空间中取，修改时就修改这个空间中的数据。对数据操作时，redux提供的对应的方法\n    2. 安装：npm install --save redux\n       调试工具：npm install --save-dev redux-devtools\n    3. 三大原则\n        1.单一数据源\n            整个应用的 state 被储存在一棵object tree中，并且这个 object tree 只存在于唯一一个 store 中。\n        2.使用纯函数来执行修改\n            如何改变 state tree ，你需要编写 reducers。它接收先前的 state 和 action，并返回新的 state\n        3.State 是只读的\n       唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。执行上面纯函数。\n\n    4. 核心 store \n        1. store是存储数据的空间\n        2. 创建存储空间语法：\n            import {createStore} from 'redux'\n            const store = createStore(reducer,init)\n        3. store上会提供操作数据的方法\n            1. 获取数据 getState()\n            2. 修改数据 dispatch()\n            3. 监听方法 subscribe()\n\n    5. 核心2 reducer\n        1. reducer 提供可预测化的状态管理\n        2. reducer 必须是一个纯函数\n            function reducer(state,action){\n                switch(action.type){\n                    case 'ADD':\n                        state = state + 1;\n                        return state;\n                    default:\n                        return state\n                }\n            }\n        3. 这个reducer是放在 createStore 的第一个参数位置\n\n    6. 核心3 action\n        1. 对store数据的具体操作\n        2. 格式：\n            1. 对象形式\n                {\n                    type:'ADD',\n                    payload:'xxxxx'\n                }\n            2. 函数形式\n                function XX(yy){\n                    return {\n                        type:'ADD',\n                        payload:yy\n                    }\n                }\n        3. action也必须是没有副作用的(网络请求，定时器)\n        4. 触发action执行：\n            调用store上的dispatch方法，把action放在dispatch中\n\n    7. reducers合并\n        1. 如果一个store中要存储多个公共数据，这些公共数据的操作又是不一样的\n        2. 需要创建多个reducer,每个reducer中都保存相关的一组数据\n        3. createStore(reducer)中只有第一个参数位置是放reducer的，而且只能放一个\n        4. redux中提供了一个方法，combineReducers ，作用就是把多个reducer合并成一个\n        5. combineReducers语法：\n            import {combineReducers} from 'redux'\n            const all = combineReducers({\n                reducer1:reducer1,\n                reducerA\n            })\n            返回值：all ，也是一个函数\n        6. 把合并后的all放到 createStore(all),\n            1. store中就有多个reducer中的数据了\n            2. store.dispatch()能触发所有reducer中的功能\n    8. 支持异步action\n        1. 需要使用中间件 ： redux-thunk\n        2. 安装：npm i redux-thunk -S\n        3. 配置store支持中间件\n            import {applyMiddle} from 'redux'\n            import thunk from 'redux-thunk'\n            createStore(reducer,applyMiddle(thunk))\n        4. 定义异步action\n            const yibu=(url,data)=>(dispatch, getState)=>{\n                fetch(url).then(data=>data.json()).then(data=>{\n                    dispatch({\n                        type:'ADD',\n                        payload:data\n                    })\n                })\n            }\n        \n        5. 执行异步action\n            dispatch(yibu())\n        \n    9. compose\n        1. 合并applyMiddleware和其他的功能\n        2. 让浏览器插件和中间件同时工作\nconst store = createStore(all,window."),s("span",{pre:!0,attrs:{class:"token bold"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("__")]),s("span",{pre:!0,attrs:{class:"token content"}},[t._v("REDUX_DEVTOOLS_EXTENSION")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("__")])]),t._v(" && window."),s("span",{pre:!0,attrs:{class:"token bold"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("__")]),s("span",{pre:!0,attrs:{class:"token content"}},[t._v("REDUX_DEVTOOLS_EXTENSION")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("__")])]),t._v("())\n         composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ||compose\n const store = createStore(reducer,composeEnhancers(applyMiddleware(thunk,logger)));\n\n3. react关联redux\n    1. 安装一个库，react-redux\n        npm i react-redux -S\n    2. 使用 react-redux 把react项目和redux关联起来\n        import {Provider } from 'react-redux'\n        import store from 'redux3.js'\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("Provider")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("store")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),t._v("{store}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("App")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("Provider")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    3. 在组件中使用redux数据\n        import {connect} from 'react-redux'//引入高阶组件\n        export default connect(mapStateToProps,mapDispatchToprops)(Son)\nConnect里面是两个函数可定义\n      1. 把store的存储的数据放到组件的props上\n         function mapStateToProps(state){\n \t \tconsole.log('son',state); \n \t\treturn {user:state}\n}\n2.把store上的dispatch方法给组件使用\nfunction mapDispatchToprops(dispatch){\n    return {\n        changeuser:(data)=>dispatch({\n            type:'ADD',\n            payload:'花里胡哨'\n        }),\n        deldel:(data)=>dispatch({\n            type:'DEL'\n\n        })\n}\n}\n\n")])])]),s("p")])}),[],!1,null,null,null);a.default=e.exports}}]);